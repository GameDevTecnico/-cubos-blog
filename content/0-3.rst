0.3 is here!
############

:date: 2024-08-02 10:00:00
:category: Release
:summary: Cubos 0.3 Release!

.. role:: dim
    :class: m-text m-dim

New 0.3 Features
================

On this release, we focused on adding essential features we've been wanting to have for quite some time now.
It ended up being a tad smaller than expected, as we spent a lot of time working on non-code related stuff, such as rebranding the project.
**TODO: should we introduce the rebranding here?**

This blog post covers the most important changes, but you can check out the full changelog in our `repository <https://github.com/GameDevTecnico/cubos/blob/main/CHANGELOG.md>`_.

On the Editor
-------------

Console Plugin :dim:`(@Scarface1809)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO: describe changes, add a screenshot

On the Engine
-------------

A New Physics Solver :dim:`(@fallenatlas)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Upon discovering some potential issues with regards to NVidia's patent of XPBD, some problems with how XPBD handled friction, and stability,
we decided that this would be the ideal moment to switch to another solver. 
Recently, Erin Catto shared his `comparison of multiple solvers <https://box2d.org/posts/2024/02/solver2d/>`_, and the results of TGS Soft seemed quite promising, so we decided to give it a try... And at this point, our simulation is already more stable than before!

In simple terms, it differs from XPBD in the sense that it uses impulses instead of changing the position of the bodies directly, however, like XPBD it also uses substeps. On top of this it also uses soft constraints, which is what Soft stands for in it's name.

Since these changes were mostly in internal systems, from a user stand point, everything works the same way.

Additionally, we added Friction and Bounciness. For now, these are a predefined value for every body, but will be customizable in the next release with a ``PhysicsMaterial``.

.. image:: images/complex_physics_sample_tgs_soft.gif

Raycasting :dim:`(@diogomsmiranda)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Raycasting is a commonly used tool in game development which we Cubos were lacking until now!

Raycasting is a technique used to determine the intersection of a ray with an object in a scene, right now in Cubos there are 2 shapes of colliders,
the ``BoxCollisionShape`` and the ``CapsuleCollisionShape``.

Because of this, the new system argument ``Raycast`` implementation can be divided into 2 parts, **collision with boxes** and **collision with capsules** (notice that a sphere is a capsule with no height).

**Collision with a Box**

The collision with a box is based on the Cyrus-Beck algorithm, which is a line clipping algorithm that is used to find the intersection of a line segment with a convex polygon.

We can easily define a box by the minimum and maximum values of x,y,z and the ray by its origin and the direction.

A ray is defined then by the line formula:

.. math:: point = ray.origin + t * ray.direction

Being t a scalar value that represents the distance from the ray's origin to the point.

Our objective is to find t, and check if the point is in the "right" side of the ray (the side that the ray is pointing to).

For that we can rearrange the previous formula to:

.. math::

    t = (point - ray.origin) / ray.direction

    OR (when decomposed in x,y,z)

    tX = (point.x - ray.origin.x) / ray.direction.x
    tY = (point.y - ray.origin.y) / ray.direction.y
    tZ = (point.z - ray.origin.z) / ray.direction.z

If the point is in the right side of the ray, then the intersection point is the point that is closest to the ray's origin.

Now, the only thing that we still need to account is, that most of the times, we have 2 intersection points, one going in, and one going out.

For this we can change the way we use this formulas by instead of using the point, we use the minimum and maximum values of the box.

If both our t's make sense, then we have an intersection.

Here is an excerpt taken from the ``Raycast`` class:

.. code-block:: cpp
    
    static float intersects(cubos::engine::Raycast::Ray ray, cubos::core::geom::Box box)
    {  
        (...)

        glm::vec3 max = corners[1];
        glm::vec3 min = corners[0];

        float tMinX = (min.x - ray.origin.x) / ray.direction.x;
        float tMaxX = (max.x - ray.origin.x) / ray.direction.x;
        float tMinY = (min.y - ray.origin.y) / ray.direction.y;
        float tMaxY = (max.y - ray.origin.y) / ray.direction.y;
        float tMinZ = (min.z - ray.origin.z) / ray.direction.z;
        float tMaxZ = (max.z - ray.origin.z) / ray.direction.z;

        // find the maximum of the min
        float tMin = std::max(std::max(std::min(tMinX, tMaxX), std::min(tMinY, tMaxY)), std::min(tMinZ, tMaxZ));

        // find the minimum of the max
        float tMax = std::min(std::min(std::max(tMinX, tMaxX), std::max(tMinY, tMaxY)), std::max(tMinZ, tMaxZ));

        if (tMax < 0 || tMin > tMax)
        {
            return -1.0F;
        }

        return tMin < 0.0F ? tMax : tMin;
    };

**Collision with a Capsule**

The collision with a capsule is more straight forward than the collision with a box, as we can separate a capsule into 3 parts, 
a cylinder and the two spheres at the ends.

We then can check for a point of intersection by checking if the ray intersects the cylinder, and if it doesn't, we check if it intersects the spheres.

We can determine both intersections by simply subbing the the ray's equation for x and z in the cylinder and sphere equations, and then solving it for t.

Code excerpt from raycast.cpp for the cylinder intersection:

.. code-block:: cpp
    
    static float intersects(cubos::engine::Raycast::Ray ray, float radius, float top, float bottom)
    {
        // We are gonna use the quadratic equation made by subbing the ray equation into the cylinder equation
        // The cylinder equation is:
        // x^2 + z^2 = r^2
        // The ray equation is:
        // x = x0 + t * dx
        // z = z0 + t * dz

        float a = ray.direction.x * ray.direction.x + ray.direction.z * ray.direction.z;
        float b = 2.0F * (ray.direction.x * ray.origin.x + ray.direction.z * ray.origin.z);
        float c = ray.origin.x * ray.origin.x + ray.origin.z * ray.origin.z - radius * radius;

        float discriminant = b * b - 4.0F * a * c;
        if (discriminant < 0)
        {
            return -1.0F; // no intersection with the cylinder
        }

        float t1 = (-b + std::sqrt(discriminant)) / (2.0F * a);
        float t2 = (-b - std::sqrt(discriminant)) / (2.0F * a);

        float max = std::max(t1, t2);
        float min = std::min(t1, t2);

        float t = min > 0.0F ? min : max;

        if (t < 0.0F)
        {
            return -1.0F; // no valid intersection
        }

        float y = ray.origin.y + t * ray.direction.y;

        if (y < bottom || y > top)
        {
            return -1.0F; // intersection is outside the finite cylinder
        }

        return t;
    };

To use the ``Raycast`` argument system, you can simply call the system ``Raycast.fire`` that takes a ``Ray`` as an argument.

.. code-block:: cpp

    cubos.system("raycast").call([](Raycast raycast)
    {
        // raycast from the origin to -50,0,0
        auto hit = Raycast.fire({{0.0F,0.0F,0.0F},{-50.0F,0.0F,0.0F}});
        if (hit.contains())
        {
            // hit.point is the point where the ray hit the object
            // hit.entitiy is the entity that was hit
        }
    });

Spot Light Shadows :dim:`(@tomas7770)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Our graphics renderer has received a new major feature in this release: shadows!

.. image:: images/scraps_vs_zombies_shadows.png

It should go without saying that this feature has a big impact on the visuals of games
developed with Cubos. We've tried it on *Scraps vs Zombies* and the result is stunning!
It's an important step towards the kind of appealing graphics that we hope to achieve.

For the time being, shadows support is limited to spot lights. To enable them, all you need
to do is add a `SpotShadowCaster <https://docs.cubosengine.org/structcubos_1_1engine_1_1SpotShadowCaster.html>`_ component to the spot lights for which you want shadows to be cast,
as shown in the `Shadows sample <https://github.com/GameDevTecnico/cubos/tree/main/engine/samples/render/shadows>`_.
Both hard and soft shadows are supported, with a configurable `blurRadius <https://docs.cubosengine.org/structcubos_1_1engine_1_1ShadowCaster.html#a450e1d2c732f1c38403a428eb0536660>`_.

Behind the scenes, this works by rendering the world from each light's perspective to determine which parts
are occluded, and making these parts unlit. A large texture known as the "shadow atlas" holds this information for
every light in a quadtree structure, reducing expensive texture switching. Finally, soft shadows are implemented
as a post-processing step that effectively blurs out the shadows.
Below is a screenshot of the shadow atlas with 5 spot lights. Lines have been drawn separating
the areas of the atlas reserved for each light.

.. image:: images/shadow_atlas.png

Initial UI Plugin :dim:`(@DiogoMendonc-a)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO: describe changes, add screenshots, maybe gifs too?

Arbitrary Input Combinations for Actions and Axes :dim:`(@luishfonseca)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

TODO: describe changes, show input bindings example

TODO: describe changes, add screenshots, maybe gifs too?

On the Core
-----------

Metrics :dim:`(@roby2014)`
~~~~~~~~~~~~~~~~~~~~~~~~~~

We are excited to introduce the new metrics and profiling utilities! 
This started becoming a priority since we detected lots of performance issues in the last Game Jam we participated.

These tools are designed to help track performance and gather valuable insights about code execution and data.

How it looks:

.. code-block:: cpp

    static void compute()
    {
        CUBOS_PROFILE();
        // ...
    } // after the scope ends, a new metric `compute` will be added, with the duration of this scope

    static void myFunction() 
    {
        /// simulate profiling loop
        for (int i = 0; i < 1337; ++i)
        {
            // simulate frame by calling a function that does work..
            compute();

            // register some metrics, this could be FPS, entities count, ....
            CUBOS_METRIC("count", i);
        }
    }

Currently, metrics can be accessed manually through the singleton class. However, we plan to 
integrate these metrics into our editor for a more streamlined experience.

Learn more about it on our `metrics documentation <https://docs.cubosengine.org/examples-core-metrics.html>`_ : 

Networking Utilities :dim:`(@roby2014)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In the 0.3 release, Cubos finally has networking! This is a big step forward for our engine, bringing 
powerful networking utilities such as ` Address <https://docs.cubosengine.org/classcubos_1_1core_1_1net_1_1Address.html>`_, 
`UdpSocket <https://docs.cubosengine.org/classcubos_1_1core_1_1net_1_1UdpSocket.html>`_, `TcpListener <https://docs.cubosengine.org/classcubos_1_1core_1_1net_1_1TcpListener.html>`_, 
and `TcpStream <https://docs.cubosengine.org/classcubos_1_1core_1_1net_1_1TcpStream.html>`_. 

Creating an UDP client and sending a message is as simple as:

.. code-block:: cpp

    UdpSocket client;
    client.bind(8080, Address::LocalHost);
    
    const char* msg = "Hello, I'm a Cubos UDP client!";
    client.send(msg, std::strlen(msg), Address::from("server.com"), 8081))

Learn more about it on our `networking documentation <https://docs.cubosengine.org/examples-core-networking.html>`_ : 

Groundwork for a Standalone Editor :dim:`(@RiscadoA)`
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The original main goal for this version was to get a first prototype of our standalone editor working.
Sadly, I didn't manage to get it done in time, as it was a bigger task than I anticipated.

The initial approach, to which I dedicated most of my time, was to have two instances of Cubos running at the same time, on the **same process** - one for the editor and one for the game.
The game instance would be running within the editor instance, and would be launched by loading the game's code from a shared library (such as a DLL).
With this separation, it would be possible for the editor to interact with the game, pause it, restart it and so on, even across game code changes, without having to restart the editor.

So, with this in mind, I restructured some parts of the code base to get it flexible enough to support this kind of setup.
Namely, it is now possible to step Cubos instances, reset them, restart them, and other similar operations.
I also added cross platform support for loading Cubos instances from shared libraries, so that we could load the game from the editor. 

This all seems, at first, perfect, but after discussing with the team, we realized that this approach of having two Cubos instances in the same process is not ideal at all.
Any game crash would bring down the editor, any memory leak in the game would affect the editor, and infinite loops in the game would freeze the editor.
Since solving the halting problem isn't in our roadmap, we decided that we should discard this approach, and instead try to keep the **editor and the game in two separate processes**.

So, for the next release, I'll be focusing on following this new approach. It will be a big task, and it will be a lot more difficult, as it will require a lot of inter-process communication, but it will be worth it in the end.
It will allows us to have a stable editor, whose performance is not affected (that much at least) by the game, and vice-versa.

Next Steps
==========

**TODO: I just copied this from the previous post, we should rewrite it:**
We're very happy with the progress we've made on this release. The engine is becoming more and more powerful, and we were able to create a full game with it in a week!

For the next release, which should be out in September, we'll be **WIP**

* A **standalone editor application**. Our tools are currently integrated into the games themselves which is not ideal.
* **Audio support**, as there's no sound at all in the engine right now.
* Actual **voxel collisions**, as we currently only check the bounding boxes.
* Basic **rigidbody physics**, with rotation and friction.
* **Shadows** for all light types.
* **Web-support**, so that games can be played in the browser.
* **Tracing and spans**, for better tracking of program execution.
* **TODO: what else? review stuff above too**

You can check out the full list of stuff we want to get done in the `milestone <https://github.com/GameDevTecnico/cubos/milestone/27>`_ for the next release.

We're currently a team of 13 people, and **we're looking to expand**! If you're interested in joining us, or just want to learn more about the project, join our `Discord server <https://discord.gg/WjTtcNTRqD>`_!
